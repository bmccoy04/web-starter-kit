# Notes

## Tech Stack

* ASP.NET Core MVC 1.1.1 
* Entity Framework Core 1.1.1
* AutoMapper 6.0.2
* FluentValidation 6.4.1
* SimpleInjector 3.3.2

## Setup

** Press F5 from Visual Studio 2017 

## Authentication

None currently in place.

## Structure ofs API Project

* Controllers - API controllers...
* Filters - Web API Pipeline filters (exceptions, etc.)
* Configuration - (cors, mvc, dependency inversion, swagger, etc.)

## Structure of Core Project

* Features - All major application features and their parts (Request Dto, Response Dto, Mapper, Handler, Validator)
* Configuration - Configuration settings
* Dtos - All common Dtos used across the app - do not include feature specific Dtos here.
* Data - Data access related features 
* Domain - Domain models/entities for the project
* Extensions - Extension methods
* Logging - Logging specific concerns
* Mediator - Architectural pipeline concerns 
* Migrations - Generated by Entity Framework 
* Validation - Common validation across the entire application.  Do not add feature specific validation handlers here.

## How to Build Service Endpoints with this Architecture 

Our architecture is based on the SOLID design principles and utitlizes the mediator and decorator design patterns to allow our apps to 
define an extensible pipeline of activities for requests instead of forcing those concerns to a framework such as ASP.NET Web API. 

The following blog illustrates some of our concepts quite well: 
https://lostechies.com/jimmybogard/2014/09/09/tackling-cross-cutting-concerns-with-a-mediator-pipeline/

To better understand how to use this architecture, let's go through the user example in this start up project.  We'll be using users.
A ```User``` has a first and last name, an active field, and a collection of claims. ```Claims``` have a name and an optional value.  
For this example, we will show adding how to build the components to add a user.

1. Build the domain objects (if it doesn't exist already)
The final solution for this step is the ```User``` and ```UserClaim``` classes found in *TC.Core/Domain*. 

2. If the database table does not exist for users, from your *Package Manager Console*, run ```add-migration "User"```.  
This command will scaffold a migration script for any pending model changes. 
**NOTE:** As we have automatic migrations setup, you should NOT have to run the *update-database* command.  
Running the API project will automatically migrate.

3. Build out your Request and Response (if necessary) objects.
The final solution for this step is ```AddUserRequest``` and ```AddUserResponse```.  Both can be found in AddUserRequest.cs
**NOTE:** If your handler only needs to return an HTTP Response class, do not create a feature-specific response class; instead, use the ```Response``` class found in 
*TC3.Core\Dtos\Response.cs*.  

4. Build your request handler.
The final solution for this step is ```AddUserRequestHandler``` which can be found in AddUserRequest.cs.  Note, by convention, all handlers
end in ```RequestHandler```.

5. Build your validator 
The final solution for this step is ```AddUserValidator``` which is found in AddUserRequest.cs. 
**NOTE:** Rarely you write handlers that do not require a ```Validator```.  In these rare cases, simply
wrap your handler with a *[DotNotValidate]* attribute and the ```Mediator Pipeline``` will pick that up and not run your request against
the ```ValidationHandler```.  An example of this is ```GetUsersRequestHandler``` which is found in GetUsersRequest.cs.

6. Build your endpoint 
The final solution for this step is the AddUser method of the ```UsersController``` class found in *TC3.Api\Controllers\UsersController.cs*.  Please note how small
the controller methods are.  This should always be the case.
**NOTE:** The ```[ProducesResponseType..., (int)HttpStatusCode.OK)]``` attribute is for Swagger.  
It shows a developer viewing Swagger the shape of the Response object as well as the expected HTTP status code.

7. Write your appropriate unit tests.  At a minimum, you should unit all validators and any handlers that have business logic more than just simple crud.  
See our unit testing project as an example.

Some References:
  * https://www.asp.net/core (ASP.NET Core)
  * https://docs.microsoft.com/en-us/ef/core/ (Entity Framework Core)
  * https://github.com/AutoMapper/AutoMapper/wiki/Getting-started (AutoMapper)
  * https://github.com/JeremySkinner/FluentValidation/wiki (Fluent Validation)
  * https://simpleinjector.readthedocs.io/en/latest/index.html (Simple Injector)